 ### 209.长度最小的子数组
```
func minSubArrayLen(target int, nums []int) int {
    slow, fast := 0,0
    count := math.MaxInt32
    sum := 0
    for fast < len(nums) {
        sum = sum + nums[fast]
        for sum >= target{
            if count > fast - slow + 1 {
                count = fast - slow + 1
            }
            sum = sum - nums[slow]
            slow ++
        }
        fast ++
    }
    if count > len(nums){
        return 0
    } else {
        return count
    }
}
```
本题核心还是在于动态调整slow和fast的位置，并且时刻动态调整sum大小，fast往后走为sum+=，slow往前走为sum-=，同时记录下最小的count值。

### 59.螺旋矩阵II
```
func generateMatrix(n int) [][]int {
    left := 0
    right := n
    top := 0
    bottom := n
    matrix := make([][]int,n)
    for i:=0; i < n ; i++{
        matrix[i] = make([]int,n) //不是:=
    }
    loop := n/2
    cur := 1

    for j :=0; j < loop; j++{
        lens := right-left-1
        for k:=0; k<lens; k++{
            matrix[top][left+k] = cur
            cur++
        }
        for k:=0; k<lens; k++{
            matrix[top+k][right-1] = cur
            cur++
        }
        for k:=0; k<lens; k++{
            matrix[bottom-1][right-1-k] = cur
            cur++
        }
        for k:=0; k<lens; k++{
            matrix[bottom-1-k][left] = cur
            cur++
        }

        left++
        top++
        right--
        bottom--
    }

    if n%2 != 0{
        mid := n/2
        matrix[mid][mid] = n*n
        return matrix
    } else {
        return matrix
    }

}
```
本质是数学题，需要明白loop圈数和n的关系：
已知每转一圈会缩小，缩小的范围从矩阵来看则是左右，上下边界各-1，也就是矩阵的行列每转一圈要-2。现在就简单了，要知道n能转几圈，就是一直-2，所以loop = n/2（整除）。

接下来就是数字填充，核心是遵循左闭右开。无论是按照视频里的offset去缩圈还是自己写的，都要保持一致性。对于奇数n，转完填充最中心，偶数转完直接return。
![图片1：左闭右开转圈示意图](./images/spiral-left-closed-right-open.png)


### 58 区间和 ACM模式
```
package main
import(
    "fmt"
    "bufio"
    "os"
)

func main (){
    in := bufio.NewReader(os.Stdin)
    out := bufio.NewWriter(os.Stdout)
    defer out.Flush()
    solve(in,out)
}

func solve(in *bufio.Reader,out *bufio.Writer){
    var n int
    fmt.Fscan(in,&n)
    
    arry := make([]int,n)
    pre := make([]int,n+1) //go默认0，省写pre[0] = 0
    sum := 0
    for i:= 0; i<n;i++{
        var num int
        fmt.Fscan(in,&num)
        arry[i] = num
        sum = sum + num
        pre[i+1] = sum
    }

    for {
        var a,b int
        if _,err := fmt.Fscan(in,&a,&b);err != nil{
            break
        }    
        fmt.Fprintln(out,pre[b+1]-pre[a])
    }
}
```
本题先熟悉ACM模式，除了要写核心函数外还需要自行处理输入输出。

<details>
<summary><strong>ACM 输入输出模板（读到 EOF）</strong></summary>

```go
package main

import (
    "bufio"
    "fmt"
    "os"
)

func main() {
    in := bufio.NewReader(os.Stdin)
    out := bufio.NewWriter(os.Stdout)
    defer out.Flush()

    solve(in, out)
}

func solve(in *bufio.Reader, out *bufio.Writer) {
    for {
        var x int
        if _, err := fmt.Fscan(in, &x); err != nil {
            break
        }
        fmt.Fprintln(out, function(x))
    }
}
```
</details> 

核心逻辑求区间和部分，可以利用两个前缀和相减来得到。可构建arry的同时，也构建一个pre数组去直接做好求和，需要注意的是a=0的区间，有可能导致求区间和时溢出。如输入区间下标 [2, 5] 的区间和，那么应该是 p[5] - p[1]，而不是 p[5] - p[2]。可以考虑在构建 pre 数组的时候提前就按n+1去构建，输出的部分就统一简单一些了
![图片2：前缀和区间计算示意](./images/prefix-sum-range.png)


44 开发商购买土地
```

```
