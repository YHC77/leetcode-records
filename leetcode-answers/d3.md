### 203.ç§»é™¤é“¾è¡¨å…ƒç´ 
```go
func removeElements(head *ListNode, val int) *ListNode {
    dummy := &ListNode{}
    dummy.Next = head
    cur := dummy
    for cur != nil && cur.Next != nil{
        if cur.Next.Val == val{
            cur.Next = cur.Next.Next
        } else {
            cur = cur.Next
        }
    }
    return dummy.Next
}
```
dummyå¥½ç”¨ï¼Œå¯ä»¥è§„é¿å¤´å’Œå…¶ä½™èŠ‚ç‚¹åˆ é™¤åˆ†å¼€å¤„ç†çš„é—®é¢˜ã€‚è‡ªå·±æ²¡ä¸€æ¬¡è·‘é€šé”™åœ¨æ²¡ç»™å‘åç§»åŠ¨èŠ‚ç‚¹+elseï¼Œå¯¼è‡´è‹¥éœ€è¦è¿ç»­è·³è¿‡çš„æƒ…å†µå‡ºé”™ã€‚

<details>
<summary>ğŸ‘‰æ“ä½œæŒ‡é’ˆç›¸å…³çŸ¥è¯†å¤ä¹ ï¼š</summary>
goä¸Cç±»ä¼¼å¯ä»¥æ“ä½œæŒ‡é’ˆï¼ŒæŒ‡é’ˆå°±æ˜¯ä¸€ä¸ªå˜é‡ï¼Œå­˜æ”¾ç€åœ°å€ï¼š

- *ï¼ŒæŒ‡é’ˆä¿®é¥°ç¬¦ï¼Œä¸åŒä½ç½®å«ä¹‰ä¸åŒ
- *åè·Ÿå˜é‡æ˜¯è§£å¼•ç”¨ 
- *åè·Ÿç±»å‹Tï¼Œå¦‚ *Tï¼Œæ„å‘³ *T æŒ‡å‘ Tç±»çš„æŒ‡é’ˆç±»å‹ï¼Œå¦‚intï¼Œè‡ªå®šstructçš„ListNode 
- &å–åœ°å€ 

ä½†goä¸­æœ‰è¯­æ³•ç³–å¯ç›´æ¥è§£å¼•ç”¨ï¼šcur.Val = 3 ç­‰ä»·äº (*cur).Val = 3
</details>

### 707.è®¾è®¡é“¾è¡¨
```go
type MyLinkedList struct {
    dummyHead *ListNode
    size int
}

// type ListNode struct{
//     Val int
//     Next *ListNode
// }

func Constructor() MyLinkedList {
    return MyLinkedList{
        dummyHead: &ListNode{},
        size: 0,
    }
}


func (this *MyLinkedList) Get(index int) int {
    if index < 0 || index > this.size - 1{
        return -1
    }

    cur := this.dummyHead.Next
    for i:=0; i < index; i++{
        cur = cur.Next
    }
    return cur.Val
}


func (this *MyLinkedList) AddAtHead(val int)  {
    cur:=this.dummyHead.Next
    newNode := &ListNode{
        Val: val,
        Next: cur,
        }
    this.dummyHead.Next = newNode
    this.size ++
}


func (this *MyLinkedList) AddAtTail(val int)  {
    cur := this.dummyHead
    for cur.Next != nil{
        cur = cur.Next
    }
    newNode := &ListNode{
        Val:val,
        Next:nil,
    }
    cur.Next = newNode
    this.size++
}


func (this *MyLinkedList) AddAtIndex(index int, val int)  {
    if index > this.size{
        return
    } else if index == this.size{
        this.AddAtTail(val)
        return
    } else if index == 0{
        this.AddAtHead(val)
        return
    }

    cur := this.dummyHead
    for i:=0; i<index;i++{
        cur = cur.Next
    }
    newNode := &ListNode{
        Val:val,
        Next:nil,
    }
    newNode.Next = cur.Next
    cur.Next = newNode

    this.size++
}


func (this *MyLinkedList) DeleteAtIndex(index int)  {
    if index < 0 || index >= this.size{
        return
    }
    cur := this.dummyHead
    for i:=0;i<index ;i++{
        cur = cur.Next
    }
    cur.Next = cur.Next.Next
    this.size--
}
```
æœ¬é¢˜ç”¨äº†å•é“¾è¡¨å®ç°ï¼Œä¸»è¦å¤ä¹ äº†goçš„ç±»/æ–¹æ³•æ„å»º+å±•ç¤ºé“¾è¡¨è™šæ‹Ÿå¤´èŠ‚ç‚¹çš„é‡è¦æ€§ï¼Œåœ¨å¢åˆ è¿™ä¸¤å¤§æ“ä½œä¸­éƒ½ååˆ†ä¾¿åˆ©ã€‚
<details>
<summary>ğŸ‘‰ç±»ä¸æ–¹æ³•</summary>
goæ²¡æœ‰ä¼ ç»Ÿæ„ä¹‰ç»§æ‰¿ï¼Œé æ–¹æ³•æŒ‚è½½åœ¨structä¸Šã€‚ <br>
æ–¹æ³•å³æ™®é€šå‡½æ•°å‰é¢å¤šäº†ä¸€ä¸ªstructçš„æ¥æ”¶è€…ï¼Œé€šå¸¸æ˜¯struct æˆ– *struct <br> 
æ¥æ”¶è€…æ˜¯(this struct)æ—¶ï¼Œæ–¹æ³•æ“ä½œçš„æ˜¯å‰¯æœ¬ï¼Œä¸å½±å“æœ¬ä½“é“¾è¡¨  <br>
æ¥å—è€…æ˜¯(this *struct)æ—¶ï¼Œæ–¹æ³•æ“ä½œçš„æ˜¯æœ¬ä½“é“¾è¡¨

</details>


### 206.åè½¬é“¾è¡¨
```go
func reverseList(head *ListNode) *ListNode {
    dummy := &ListNode{Next: nil}
    p := dummy.Next
    cur := head
    for cur != nil{
        tmp := cur.Next
        cur.Next = p
        p = cur
        cur = tmp
    }
    return p
}
```
åè½¬çš„æµç¨‹å…ˆç”»å‡ºæ¥ï¼Œå°±å¾ˆå¥½å†™äº†ï¼š
1.ä¿ç•™åç»­èŠ‚ç‚¹åœ°å€
2.æœ¬èŠ‚ç‚¹NextæŒ‡å‘ä¸Šä¸€èŠ‚ç‚¹åœ°å€
3.å°†ä¸Šä¸€èŠ‚ç‚¹å˜é‡èµ‹å€¼ç§»åŠ¨åˆ°æœ¬èŠ‚ç‚¹
4.æœ¬èŠ‚ç‚¹å€Ÿç”±tmpä¿å­˜çš„åç»­èŠ‚ç‚¹åœ°å€èµ‹å€¼å®ç°ç§»åŠ¨
æœ€åè¿”å›çš„æ˜¯pä¸æ˜¯curï¼Œç„¶åå…¶å®æ²¡å¿…è¦å®šä¹‰dummyï¼Œç›´æ¥var ä¸€ä¸ªç©ºæŒ‡é’ˆå°±å¥½